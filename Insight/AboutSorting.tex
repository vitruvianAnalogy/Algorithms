HEAPSORT is too complicated. You need to recheck the visual algorithms, or maybe a youtube video
But here are the basic three procedures
1. Heapify - First of all we create a maxheap or minheap. Maxheap for ascending, minheap for descending.
2. Once we have created the maxheap, we remove the right most leaf and replace it with the first element which right now due to the heapify operation
is the largest operation.
3. Once we do this swap operation it becomes the last element and now ,.....
4. And then we again HEAPIFY. AGAIN. Because we have removed the maximum element and now the smallest element is on the top.
5. So we heapify again and we go again bottom up but since the largest element has found its place already we start heapifying from the second leaf from the right.


MERGESORT
1. It is divided into two parts and is recursively sorted. 
2. Once we have recursively sorted it. We merge it and sort it.


QUICKSORT
1. Just like merge sort we divide it but besides dividing it right in the middle, we can also try to take a random point or the first element, or the last element
2. When we find the pivot, we try to get closer to the pivot from both sides while checking if some number disturbs the order while we get there. If we reach
from both sides then it means the list is sorted. If it doesn't reach the pivot from both sides then we sort it again ignoring the already sorted part
and just focus on the part between the pivot and upto the index where the order was maintained.
3. So basically it is like mergesort but we don't go down the recusion stack unless we find some element that disturbs the order.


BUBBLE SORT
1. The BRUTE FORCE method that i use is not this. Bubble sort actually runs linear time for best case. 
2. We compare consecutive elements and bring the biggest element to the end.
3. Second pass we again compare consecutive element but this time we bring second largest element to the end.
4. With each pass the number of steps is decreased by one.


INSERTION SORT
1. We start from the second element and check if all the elements before it are sorted. if not, we sort it
2. Like this we move from each increasing index backwards to check if all the elements before it are sorted or not.


SELECTION SORT
1. Start from index 1 , find the minimum element and put it at the front.
2. Start from index 2 and put the minimum element on index 2
3. And so on


SHELLSORT
1.Instead of checking close by element, it compares with far off elements. 		<Not focusing much right now>

